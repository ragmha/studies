# Imperative Programming

## About
*   modifying mutable variables
*   using assignments
*   control structures such as if-then-else, loops, break, continue , return

> The most common  informal way to understand imperative programs is as instruction sequences for a Von Neumann computer.

```
 VON NEUMANN

============					       ==========
|	Processor |   <========>   | Memory  |
|				    |		   BUS	     |         |
============				         ==========

```
## Imperative Programs and Computers

 ``` ˜=   <--- means correspondence ```

## There's a strong correspondence between

*   Mutable variables  ˜=  memory cells

*   Variable dereferences  ˜=  load instructions

*   Variable assignments  ˜=  store instructions

*   Control structures  ˜=  jumps


*   In the end, pure imperative programming is limited by the "Von Neumann" bottleneck:

*   "One tends to conceptualise data structures word-by-word"

*   In order to Scale up, we would need high-level abstractions such as collections, polynomials, geometric shapes, shapes, documents
